---
title: 2024.07.21百度提前批一面
date: 2024-07-21
category:
  - 百度
  - 一面
  - 秋招
---

# 2024.07.21百度提前批一面

### 1、自我介绍

### 2、HashCode（）和equals（）方法的关系

equals相等的两个对象的hashCode也一定相等，但hashCode相等的两个对象不一定equals相等。

### 3、重载和重写有什么区别？

- **重载（Overload）**：

- - 重载是指在同一个类中，可以定义多个方法具有相同的名称但是参数列表不同（包括参数的类型、顺序和个数）的情况。
  - 重载方法的返回值类型可以相同也可以不同，但不能仅仅通过返回值类型的不同来区分重载方法。

- **重写（Override）**：

- - 重写是指子类可以定义一个与父类中的某个方法具有相同名称、参数列表和返回类型的方法，从而覆盖父类中的方法实现。
  - 重写方法必须与父类方法具有相同的方法签名（包括方法名、参数列表和返回类型），但可以拥有不同的方法体。

- 

### 4、讲一讲乐观锁和悲观锁

- 悲观锁，就是认为在最坏的情况下，每次读取数据的时候，该数据都会被他人修改，所以每次取数据之前，都要加锁。只有拥有该锁的人，才可以对该数据进行操作。其他人要操作该数据的话，必须等到持有锁，才能进行操作。悲观锁适用于“写”操作比较多的情况，在java中，syschronized（重量级锁）和ReentrantLock(重入锁)都是悲观锁，每次只能有一个线程访问。
- 乐观锁，就是认为在最好的情况下，每次取数据的时候，他人都不会更改该数据。乐观锁其实并不是真正的锁，乐观锁是一种无锁机制，没有使用锁，但是可以实现线程间的同步。乐观锁试用于多“读”的情况。即资源间竞争较少的情况。这样可以提高cpu的吞吐量。主要有版本号和CAS两种方式实现

### 5、讲一讲CAS原理

CAS（Compare-and-Swap，比较并交换）的原理如下：

它包含三个操作数：内存位置 V、预期原值 A 和新值 B。当执行 CAS 操作时，会先比较内存位置 V 的值是否等于预期原值 A，如果相等，就将该位置的值更新为新值 B；如果不相等，说明在此期间该值已经被其他线程修改了，则不进行更新操作。

CAS 是一种无锁算法的实现机制，通过硬件指令来保证原子性操作，它在多线程环境下能高效地实现对共享变量的同步操作，是许多并发框架和工具的重要基础。然而，它也存在一些ABA 问题等局限性。

### 6、ABA问题，怎么解决

ABA 问题是指在使用 CAS 操作时可能出现的一种情况。假设一个共享变量初始值为 A，线程 T1 将其先修改为 B，然后又修改回 A，在这个过程中另一个线程 T2 进行 CAS 操作，它比较时发现值仍然是 A，就认为没有被其他线程修改过而进行了更新操作，但实际上在此期间已经发生了从 A 到 B 再到 A 的变化，这就是 ABA 问题。它可能会导致一些在特定场景下不符合预期的结果。解决办法如下：

1. **使用版本号**：为数据增加一个版本号字段，每次修改数据时版本号递增，这样就可以区分不同的修改过程，而不仅仅是比较值是否相同。
2. **添加标记**：可以添加一些额外的标记来标识数据的状态变化过程，而不仅仅依赖于原始数据的值。

### 7、synchroized是什么锁？跟JDK版本关系，jdk8以前和以后有什么区别

`synchronized`是一种互斥锁。

在 JDK 8 以前，`synchronized`主要通过重量级锁来实现，性能开销相对较大。

在 JDK 8 及以后，对`synchronized`进行了优化。引入了偏向锁和轻量级锁等机制，在没有激烈竞争的情况下，可以减少锁获取和释放的开销，提高了性能。偏向锁适用于只有一个线程频繁获取锁的场景，轻量级锁则适用于线程交替执行获取锁的情况，当竞争激烈时才会升级为重量级锁。这些优化使得`synchronized`在很多场景下的表现有了显著提升。

### 8、线程的状态，分别介绍

在操作系统中，线程被视为轻量级的进程，所以**线程状态其实和进程状态是一致的**。

- **创建状态(new)**：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)**：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)**：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)**：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)**：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

![img](https://s2.loli.net/2024/07/21/3wTPKyInfHFtJ61.webp)

在Java中：

+ **新建（New）**：线程刚被创建，还未启动。
+ **就绪（Runnable）**：线程正在 CPU 上执行。
+ **阻塞（Blocked）**：线程因等待某个条件（如获取锁、等待 I/O 操作完成等）而暂停执行。
+ **等待（Waiting）**：线程处于无限期等待状态，需要其他线程唤醒。
+ **超时等待（Timed_Waiting）**：线程处于有限时间的等待状态，时间到后会自动唤醒或被其他线程唤醒。
+ **终止（Terminated）**：线程执行完毕或异常终止。

![aaa.png](https://s2.loli.net/2024/07/21/73ibAfUuY4M5VB8.webp)

### 9、出现SQL慢查询，怎么排查

[链接](https://blog.csdn.net/qq_48508278/article/details/127043949#:~:text=1%3A查看数据库服务慢查询日志是否开启 2%3A开启慢查询日志,3%3A查看慢查询阈值（超过这个时间sql就会被记录在慢查询日志中） 4%3A我们更改一下阈值（因为我们的测试数据插叙时间基本上是不会超过10s的）)

```sql
1. 开启慢查询日志
show variables like 'slow_query_log';
set global slow_query_log=on;
2.更改慢查询阈值
show variables like 'long_query_time';
set long_query_time=0.3;
3. 查看慢查询日志位置
show variables like 'slow_query_log_file';
```

这时候查看日志文件，可以看到慢查询的语句，然后再对语句分析，可以使用explain语句，看是否走索引，没有索引可以加个索引或者优化sql语句，尽量走索引

回答：

1. **分析 SQL 语句结构**：检查是否存在复杂的多表连接、不必要的子查询等。
2. **查看慢查询日志**：确定具体是哪些 SQL 语句执行慢。
3. **检查索引**：explain看是否缺少合适的索引，或者索引是否失效。

### 10、异常处理相关的注解，怎么定义和捕获全局异常处理器

通过 `@ControllerAdvice` 注解标记该类为全局异常处理类，然后使用不同的 `@ExceptionHandler` 来处理特定类型的异常。

### 11、用过SpringBoot中传入参数校验的注解吗？

在 Spring Boot 中常用的参数校验注解有很多，比如：

- `@NotNull`：表示该字段不能为空。
- `@NotEmpty`：表示该字段不能为空字符串或集合不能为空。
- `@Size(min=, max=)`：限制字段的长度范围。
- `@Min`：限制数值的最小值。
- `@Max`：限制数值的最大值。

### 12、算法，有一个数列，求最大的连续子序列值

https://leetcode.cn/problems/maximum-subarray/description/

动态规划：`f[i]=max(f[i-1]+nums[i],nums[i]);`

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> f(n+100);
        int res=-10086;
        //f[i]表示以i结尾的最大连续子数组的和 f[i]=max(f[i-1]+nums[i],nums[i]);
        for(int i=1;i<=n;i++){
            f[i]=max(f[i-1]+nums[i-1],nums[i-1]);
            res=max(res,f[i]);
        }
        return res;
    }
};
```

### 13、反问环节